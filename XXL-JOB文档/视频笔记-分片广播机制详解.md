# 视频笔记：XXL-JOB 分片广播机制详解

> 黑马程序员《学成在线》项目 - XXL-JOB 分片广播教学

---

## 📺 视频核心内容

### 一、为什么需要分片广播？

#### 背景问题

学成在线项目需要处理大量视频转码任务，使用分布式任务调度 XXL-JOB。

#### 普通路由策略的局限性

老师提出了一个关键问题：

> "现在有 3 个执行器，调度中心每隔 10 秒执行一次任务。
> 使用第一个、轮询、随机等策略时，每次只有 1 个执行器在工作。
> 这样做分布式任务调度的意义何在？无法充分利用集群资源！"

**8 种普通路由策略的共同弊端**：

```
第一个（FIRST）      → 每次只有执行器1工作
最后一个（LAST）     → 每次只有执行器3工作
轮询（ROUND）        → 第1次执行器1，第2次执行器2，第3次执行器3
随机（RANDOM）       → 每次随机选1个
一致性哈希          → 根据任务ID哈希选1个
最不经常使用（LFU）  → 选使用最少的1个
最近最久未使用（LRU）→ 选最久没用的1个
故障转移（FAILOVER） → 故障时切换，还是1个
忙碌转移（BUSYOVER） → 忙碌时切换，还是1个

共同点：每次调度只有1个执行器工作 ❌
```

---

### 二、分片广播的解决方案

#### 核心思想

> "分片广播可以实现：每次调度时，把任务同时发给所有执行器！"

```
调度中心
    ↓ （广播）
 ┌──┴──┬──┴──┐
执行器1 执行器2 执行器3
 ↓      ↓      ↓
同时执行 同时执行 同时执行
```

#### 关键问题：如何避免任务重复？

老师提出的问题：

> "现在有 100 个视频要处理，3 个执行器同时收到任务。
> 你让执行器 1 处理这批视频，也让执行器 2 处理这批视频，还让执行器 3 处理这批视频。
> 那这 3 个人知道自己该处理哪些视频吗？会不会重复处理？"

**答案：分片参数！**

调度中心在广播时，给每个执行器标上序号：

```
执行器1：序号 0
执行器2：序号 1
执行器3：序号 2
```

然后告诉他们：

```
执行器1（序号0）：你处理第0部分任务
执行器2（序号1）：你处理第1部分任务
执行器3（序号2）：你处理第2部分任务
```

---

### 三、两个关键参数

老师强调的重点：

> "分片参数特别的重要！没有这个参数，3 个执行器不知道该干什么活！"

```java
// 参数1：当前执行器的序号（从0开始）
int shardIndex = XxlJobHelper.getShardIndex();

// 参数2：执行器总数
int shardTotal = XxlJobHelper.getShardTotal();
```

**示例**：

```
假设有3个执行器：

执行器1获取到：shardIndex=0, shardTotal=3
执行器2获取到：shardIndex=1, shardTotal=3
执行器3获取到：shardIndex=2, shardTotal=3
```

**如何使用这两个参数？**

通过取模运算分配数据：

```sql
-- 执行器1执行：
SELECT * FROM video WHERE MOD(id, 3) = 0  -- id=0,3,6,9,12...

-- 执行器2执行：
SELECT * FROM video WHERE MOD(id, 3) = 1  -- id=1,4,7,10,13...

-- 执行器3执行：
SELECT * FROM video WHERE MOD(id, 3) = 2  -- id=2,5,8,11,14...
```

这样就保证了：

- ✅ 每个视频只被一个执行器处理（不重复）
- ✅ 所有视频都会被处理（不遗漏）
- ✅ 3 个执行器并行工作（效率高）

---

### 四、实战操作步骤

#### 步骤 1：添加分片广播方法

老师从 XXL-JOB 的示例代码中复制了分片广播方法：

```java
@XxlJob("shardingJobHandler")
public void shardingJobHandler() {
    // 获取分片参数
    int shardIndex = XxlJobHelper.getShardIndex();
    int shardTotal = XxlJobHelper.getShardTotal();

    log.info("分片参数 → 当前分片序号: {}, 总分片数: {}", shardIndex, shardTotal);

    // ... 业务逻辑
}
```

老师强调：

> "我们测试程序的目标非常明确：拿到这两个参数即可！
> 只要有这两个参数，就可以人为确定执行哪一部分任务。"

---

#### 步骤 2：启动多个执行器

**关键配置**：

老师提到需要配置两个参数：

```bash
# 参数1：服务端口（避免冲突）
-Dserver.port=63051

# 参数2：执行器端口（避免冲突）
-Dxxl.job.executor.port=9998
```

**重要提醒**：

> "你不配本地优先，用-D 参数根本不认！"

需要在配置文件中添加：

```yaml
spring:
  cloud:
    config:
      override-none: true # 本地配置优先
```

**启动实例**：

```
第1个执行器：
- server.port=63050（默认）
- xxl.job.executor.port=9999（默认）

第2个执行器：
- server.port=63051
- xxl.job.executor.port=9998

第3个执行器（可选）：
- server.port=63052
- xxl.job.executor.port=9997
```

---

#### 步骤 3：验证执行器在线

老师强调：

> "起来这端口只要有不就行了吗？不行！
> 这个执行器需要向调度中心报道的，你得在这看，必须是 2 个才行！"

**验证位置**：

```
XXL-JOB Admin → 执行器管理 → media-service-executor

应该看到：
127.0.0.1:9999 ✅
127.0.0.1:9998 ✅
```

---

#### 步骤 4：添加分片广播任务

**最关键的配置**：

| 配置项       | 值                                 |
| ------------ | ---------------------------------- |
| 任务描述     | 分片任务测试                       |
| Cron         | `0/5 * * * * ?`（每 5 秒执行一次） |
| JobHandler   | `shardingJobHandler`               |
| **路由策略** | **分片广播** ⭐⭐⭐                |

老师特别强调：

> "路由策略选哪个？分片广播！这是最关键的配置！"

---

#### 步骤 5：查看执行日志

**观察重点**：

老师在控制台看到：

```
执行器1（9999）的日志：
分片参数 → 当前分片序号: 0, 总分片数: 2

执行器2（9998）的日志：
分片参数 → 当前分片序号: 1, 总分片数: 2
```

老师的结论：

> "各位，现在他俩是不是在并行执行？对！这不就可以了吗！"

---

### 五、动态扩容机制

老师留了一个测试作业：

> "这个测试留给大家：再起一个执行器 63052，执行器端口 9997。
> 它会动态扩容，总数会自动改成 3！
> 调度中心自动识别出来了，现在又加了一个小伙伴，总数变成 3 了。"

**动态扩容原理**：

```
初始状态（2个执行器）：
执行器1: shardIndex=0, shardTotal=2
执行器2: shardIndex=1, shardTotal=2

启动第3个执行器后（下次调度）：
执行器1: shardIndex=0, shardTotal=3  ← 自动变化
执行器2: shardIndex=1, shardTotal=3  ← 自动变化
执行器3: shardIndex=2, shardTotal=3  ← 新加入

关闭第3个执行器后（再下次调度）：
执行器1: shardIndex=0, shardTotal=2  ← 自动恢复
执行器2: shardIndex=1, shardTotal=2  ← 自动恢复
```

**关键点**：无需修改配置，XXL-JOB 自动调整！

---

## 🎓 核心知识点总结

### 1. 分片广播的优势

| 对比项     | 普通路由策略   | 分片广播       |
| ---------- | -------------- | -------------- |
| 执行器数量 | 每次 1 个工作  | 所有同时工作   |
| 资源利用率 | 低（其他闲置） | 高（全部工作） |
| 处理速度   | 慢             | 快（倍数提升） |
| 适用场景   | 单点任务       | 大批量数据     |

### 2. 适用场景

✅ **适合使用分片广播**：

- 有大量数据需要处理（视频转码、数据同步）
- 数据可以分片（如按 ID 取模）
- 希望最大化处理能力

❌ **不适合使用分片广播**：

- 单次性任务（定时清理、报表生成）
- 数据无法分片
- 只需一个节点执行

### 3. 分片参数的重要性

老师总结：

> "分片广播的重点在哪里？就是分片参数！
> 你要没这个分片参数，这 3 个人知道自己该干什么活吗？不知道！
> 这两个分片参数特别的重要！"

**两个参数的作用**：

- `shardIndex`：告诉执行器"你是第几号"
- `shardTotal`：告诉执行器"总共有几个人"

有了这两个参数，执行器才知道：

- 我应该处理哪部分数据（通过取模）
- 不会和其他执行器重复
- 不会遗漏数据

---

## 💡 老师的重点强调

### 强调 1：分片广播是最重要的路由策略

> "分片广播是我们重点来学习的！"

### 强调 2：必须配置本地优先

> "你不配本地优先，你那用-D 根本不认啊！"

### 强调 3：必须在调度中心验证执行器在线

> "这个执行器需要向调度中心报道的，你得在这看，必须是 2 个才行！"

### 强调 4：路由策略必须选分片广播

> "路由策略选哪个？分片广播！这个调度策略咱都不用管它了。"

### 强调 5：分片参数是核心

> "分片广播的重点在哪里呀？就是分片参数啊！
> 你要没这个分片参数，我问你这三个人知道自己该干什么活吗？不知道！"

---

## 📊 效率对比示例

老师的讲解场景：100 个视频需要转码

### 不使用分片广播

```
使用轮询策略：
- 第1次调度：执行器1处理1个视频
- 第2次调度：执行器2处理1个视频
- 第3次调度：执行器3处理1个视频
- ...
- 第100次调度：执行器1处理最后1个视频

需要100次调度才能完成
```

### 使用分片广播

```
调度1次：
- 执行器1：同时处理 id%3=0 的视频（约33个）
- 执行器2：同时处理 id%3=1 的视频（约33个）
- 执行器3：同时处理 id%3=2 的视频（约34个）

只需1次调度，3个执行器并行完成
效率提升约3倍！
```

---

## 🔧 配置清单

### 1. 代码层面

```java
@XxlJob("shardingJobHandler")
public void shardingJobHandler() {
    // 获取分片参数
    int shardIndex = XxlJobHelper.getShardIndex();
    int shardTotal = XxlJobHelper.getShardTotal();

    // 根据分片参数查询数据
    // SELECT * FROM table
    // WHERE MOD(id, #{shardTotal}) = #{shardIndex}

    // 处理业务逻辑...
}
```

### 2. 配置层面

```yaml
# application.yml 或 nacos配置
spring:
  cloud:
    config:
      override-none: true # 本地配置优先
```

### 3. 启动参数

```bash
# 第2个实例
-Dserver.port=63051 -Dxxl.job.executor.port=9998

# 第3个实例
-Dserver.port=63052 -Dxxl.job.executor.port=9997
```

### 4. XXL-JOB 任务配置

- **JobHandler**：`shardingJobHandler`
- **路由策略**：**分片广播（SHARDING_BROADCAST）** ⭐ 核心
- **阻塞策略**：单机串行
- **Cron 表达式**：根据需求设置

---

## 📝 下节预告

老师在最后说：

> "今天呢我们就测通，到明天呢我们再去在分片广播这个策略基础之上，
> 去写我们的任务执行逻辑。"

**下节内容**：

- 基于分片广播实现真正的视频转码任务
- 如何查询待转码视频（使用 MOD 函数）
- 如何调用 FFmpeg 进行转码
- 如何更新转码状态

---

## ✅ 学习检查清单

完成视频学习后，你应该能够：

- [ ] 理解分片广播与其他路由策略的区别
- [ ] 知道为什么需要分片广播（充分利用集群资源）
- [ ] 理解 shardIndex 和 shardTotal 的含义
- [ ] 知道如何通过取模运算避免任务重复
- [ ] 会启动多个执行器实例
- [ ] 会在 XXL-JOB Admin 中配置分片广播任务
- [ ] 会查看执行日志验证分片参数
- [ ] 理解动态扩容机制

---

## 🎯 实践建议

1. **先测试，再应用**

   - 先用`shardingJobHandler`测试分片机制
   - 理解原理后再应用到实际业务

2. **观察日志**

   - 重点关注`shardIndex`和`shardTotal`的值
   - 验证多个执行器是否并行执行

3. **测试动态扩容**

   - 启动第 3 个执行器，观察参数变化
   - 关闭执行器，观察参数恢复

4. **理解取模运算**
   - 练习手动计算：id % shardTotal = shardIndex
   - 理解为什么能保证数据不重复、不遗漏

---

## 📚 相关文档

本项目已创建的文档：

1. **XXL-JOB 分片广播实战指南.md** - 详细的分片广播教程
2. **XXL-JOB 任务配置指南.md** - 所有任务配置参考
3. **快速开始-分片广播测试.md** - 5 分钟快速上手指南
4. **XXL-JOB 快速启动指南.md** - 快速启动教程
5. **XXL-JOB 集成指南.md** - 集成步骤
6. **XXL-JOB 集成完成总结.md** - 集成总结

建议学习顺序：

1. 先看本笔记（理解原理）
2. 再看"快速开始"（动手实践）
3. 最后看"实战指南"（深入应用）
