# 断点续传完整流程详解

## 一、你的问题解答

### Q1: 我的项目实现断点续传了吗？

**答案：是的！✅ 你的项目已经完整实现了断点续传功能。**

### Q2: 为什么 OSS 中的文件是完整的 mp4 文件？

**答案：因为分块文件是在**你的应用服务器**上合并的，合并成完整文件后才上传到 OSS。**

### Q3: 是把分块传到了 OSS 服务器吗？

**答案：不是！❌ 分块文件**从未**传到 OSS。分块只保存在你的应用服务器的临时目录。**

---

## 二、完整的文件流转过程

让我详细画出文件在各个位置的流转：

```
📱 用户浏览器
  ├─ 选择文件：oceans.mp4 (100MB)
  ├─ 前端分块：切成 20 块（每块 5MB）
  │   ├─ 块0: 5MB
  │   ├─ 块1: 5MB
  │   ├─ ...
  │   └─ 块19: 5MB
  │
  ↓ 逐块上传（HTTP POST）

💻 应用服务器（你的Spring Boot应用）
  │
  ├─ 【第一阶段：接收分块】
  │   ├─ 块0 → 保存到 /tmp/xc-chunks/{md5}/0
  │   ├─ 块1 → 保存到 /tmp/xc-chunks/{md5}/1
  │   ├─ ...
  │   └─ 块19 → 保存到 /tmp/xc-chunks/{md5}/19
  │
  │   临时目录结构：
  │   /tmp/xc-chunks/
  │   └── 2125298091532905922013119cc3d2e9/
  │       ├── 0  (5MB)
  │       ├── 1  (5MB)
  │       ├── ...
  │       └── 19 (5MB)
  │
  ↓ 所有分块上传完成，前端调用合并接口
  │
  ├─ 【第二阶段：合并分块】
  │   ├─ 创建临时文件：/tmp/xc-merge-abc123.tmp
  │   ├─ 读取块0 → 写入临时文件
  │   ├─ 读取块1 → 追加到临时文件
  │   ├─ ...
  │   └─ 读取块19 → 追加到临时文件
  │
  │   结果：/tmp/xc-merge-abc123.tmp (100MB完整文件)
  │
  ├─ 【第三阶段：MD5校验】
  │   └─ 计算合并文件的MD5 === 原始文件MD5？
  │       ├─ 相等 ✅ → 继续
  │       └─ 不等 ❌ → 返回"文件校验失败"
  │
  ↓ 校验成功
  │
  ├─ 【第四阶段：上传到OSS】
  │   └─ ossService.uploadFile(
  │         "/tmp/xc-merge-abc123.tmp",  ← 完整的合并文件
  │         "oceans.mp4"                  ← 原始文件名
  │       )
  │
  ↓ 上传到阿里云OSS

☁️ 阿里云OSS
  │
  └─ yangxiaobucker（Bucket）
      └── 2025/10/07/
          └── 2125298091532905922013119cc3d2e9.mp4 (100MB完整文件)

  ↓ OSS上传成功

💻 应用服务器
  │
  ├─ 【第五阶段：保存到数据库】
  │   └─ INSERT INTO media_files (
  │         id = '2125298091532905922013119cc3d2e9',
  │         filename = 'oceans.mp4',
  │         file_path = '2025/10/07/2125298091532905922013119cc3d2e9.mp4',
  │         url = '2025/10/07/2125298091532905922013119cc3d2e9.mp4'
  │       )
  │
  ├─ 【第六阶段：清理临时文件】
  │   ├─ 删除 /tmp/xc-chunks/{md5}/0
  │   ├─ 删除 /tmp/xc-chunks/{md5}/1
  │   ├─ ...
  │   ├─ 删除 /tmp/xc-chunks/{md5}/19
  │   ├─ 删除目录 /tmp/xc-chunks/{md5}/
  │   └─ 删除 /tmp/xc-merge-abc123.tmp
  │
  └─ 【完成】返回成功响应给前端
```

---

## 三、关键流程详细解释

### 3.1 分块上传到哪里？

**答案：分块只保存在你的应用服务器，从未传到 OSS！**

```java
// MediaFileServiceImpl.java - uploadChunk 方法
@Override
public RestResponse uploadChunk(String fileMd5, int chunk, String localChunkFilePath) {
    try {
        // 分块保存路径
        Path root = getChunkRootPath(fileMd5);  // /tmp/xc-chunks/{md5}/
        Files.createDirectories(root);

        // 保存到本地临时目录
        Path target = root.resolve(String.valueOf(chunk));  // /tmp/xc-chunks/{md5}/0
        Path source = Paths.get(localChunkFilePath);
        Files.copy(source, target);  // ← 保存在本地！

        return RestResponse.success(true);
    } catch (Exception e) {
        return RestResponse.validfail(false, "上传分块文件失败");
    }
}
```

**存储位置**：

- Windows: `C:\Users\你的用户名\AppData\Local\Temp\xc-chunks\{md5}\`
- Linux: `/tmp/xc-chunks/{md5}/`

### 3.2 在哪里合并的？

**答案：在你的应用服务器上合并，合并后生成完整的临时文件！**

```java
// MediaFileServiceImpl.java - mergechunks 方法（第二阶段）
// 创建临时文件用于存储合并结果
Path merged = Files.createTempFile("xc-merge-", ".tmp");
// 位置：/tmp/xc-merge-abc123.tmp

// 使用RandomAccessFile进行文件合并
try (RandomAccessFile raf_rw = new RandomAccessFile(merged.toFile(), "rw")) {
    byte[] buffer = new byte[1024 * 1024];  // 1MB缓冲区

    // 遍历所有分块，按顺序合并
    for (int i = 0; i < chunkTotal; i++) {
        Path part = chunkRoot.resolve(String.valueOf(i));  // 读取分块i

        try (RandomAccessFile raf_r = new RandomAccessFile(part.toFile(), "r")) {
            int len;
            while ((len = raf_r.read(buffer)) != -1) {
                raf_rw.write(buffer, 0, len);  // ← 写入合并文件
            }
        }
    }
}

// 现在 merged 是完整的100MB文件了！
```

### 3.3 什么时候上传到 OSS 的？

**答案：合并完成、MD5 校验通过后，才把完整文件上传到 OSS！**

```java
// MediaFileServiceImpl.java - mergechunks 方法（第四阶段）
// ===== 步骤4：上传到OSS =====
String objectName = ossService.uploadFile(
    merged.toString(),                    // ← 完整的合并文件路径
    uploadFileParamsDto.getFilename()     // ← 原始文件名（oceans.mp4）
);

// OSS收到的是：完整的100MB mp4文件
// OSS保存为：2025/10/07/{md5}.mp4
```

### 3.4 分块文件在哪里删除的？

**答案：在应用服务器上，合并成功后立即删除！**

```java
// MediaFileServiceImpl.java - mergechunks 方法（第六阶段）
// ===== 步骤6：清理临时文件 =====
// 删除所有分块文件
for (int i = 0; i < chunkTotal; i++) {
    Files.deleteIfExists(chunkRoot.resolve(String.valueOf(i)));  // 删除块0、块1...
}
// 删除分块目录
Files.deleteIfExists(chunkRoot);  // 删除 /tmp/xc-chunks/{md5}/
// 删除合并后的临时文件
Files.deleteIfExists(merged);  // 删除 /tmp/xc-merge-abc123.tmp
```

**删除位置**：应用服务器的临时目录  
**删除时机**：合并成功、OSS 上传成功、数据库入库成功之后

---

## 四、为什么要这样设计？

### 4.1 为什么不直接传分块到 OSS？

**原因 1：OSS 不支持客户端分块上传合并**

- 阿里云 OSS 虽然支持分片上传（Multipart Upload），但那是**OSS SDK 提供的功能**
- 需要使用特定的 API（InitiateMultipartUpload、UploadPart、CompleteMultipartUpload）
- 你的项目使用的是**普通的 PUT 上传**，不支持分块

**原因 2：简化实现**

- 如果用 OSS 的分片上传，需要：

  ```java
  // 初始化分片上传
  InitiateMultipartUploadRequest request = new InitiateMultipartUploadRequest(bucket, key);
  InitiateMultipartUploadResult result = ossClient.initiateMultipartUpload(request);
  String uploadId = result.getUploadId();  // 获取uploadId

  // 上传每个分片
  for (每个分片) {
      UploadPartRequest uploadPartRequest = new UploadPartRequest();
      uploadPartRequest.setUploadId(uploadId);
      ossClient.uploadPart(uploadPartRequest);
  }

  // 完成分片上传
  CompleteMultipartUploadRequest completeRequest = new CompleteMultipartUploadRequest(...);
  ossClient.completeMultipartUpload(completeRequest);
  ```

  非常复杂！

**原因 3：统一的上传接口**

- 现在你的 `ossService.uploadFile()` 是一个简单的方法
- 不管是小文件还是大文件合并后的结果，都用同一个方法上传
- 代码简洁，易于维护

### 4.2 为什么要在服务器上合并？

**原因 1：确保文件完整性**

- 服务器可以校验所有分块都已上传
- 合并后可以计算 MD5，确保文件没有损坏
- 如果直接在 OSS 上合并，无法进行这些校验

**原因 2：业务逻辑控制**

- 服务器可以决定何时合并
- 可以在合并前/后执行业务逻辑（如病毒扫描、格式转换等）
- OSS 只是存储，不应该包含业务逻辑

**原因 3：支持断点续传**

- 分块保存在服务器，可以随时检查哪些块已上传
- 用户重新上传时，已上传的块不需要重复传输
- 如果分块在 OSS 上，检查会很复杂

---

## 五、断点续传的实现机制

### 5.1 前端如何实现断点续传？

**关键代码**（`uploadtools.ts`）：

```javascript
// 针对每个分片文件进行上传处理
const readChunkMD5 = async (num) => {
  if (num <= chunkCount - 1) {
    // 得到当前需要上传的分片文件
    const chunk = getChunkInfo(file, num, chunkSize);

    // 🔥 关键！上传分块前先检查是否已存在
    await checkchunk({ fileMd5: fileMD5, chunk: num }).then(async (res) => {
      if (res.code == 0 && res.result == false) {
        // ❌ 分块不存在，需要上传
        // ... 执行上传 ...
      } else {
        // ✅ 分块已存在，跳过！（断点续传的核心）
        success({ num, chunkCount, state: "uploading" });
        readChunkMD5(num + 1); // 直接上传下一块
      }
    });
  }
};
```

**断点续传示例**：

**第一次上传（上传到一半中断）**：

```
块0  → checkchunk → 不存在 → uploadchunk → ✅ 成功 → 保存到服务器
块1  → checkchunk → 不存在 → uploadchunk → ✅ 成功 → 保存到服务器
块2  → checkchunk → 不存在 → uploadchunk → ✅ 成功 → 保存到服务器
块3  → checkchunk → 不存在 → uploadchunk → ✅ 成功 → 保存到服务器
块4  → checkchunk → 不存在 → uploadchunk → ✅ 成功 → 保存到服务器
块5  → checkchunk → 不存在 → uploadchunk → ❌ 网络中断！用户关闭浏览器
```

**服务器上的状态**：

```
/tmp/xc-chunks/2125298091532905922013119cc3d2e9/
├── 0  (5MB) ✅ 已上传
├── 1  (5MB) ✅ 已上传
├── 2  (5MB) ✅ 已上传
├── 3  (5MB) ✅ 已上传
└── 4  (5MB) ✅ 已上传
```

**第二次上传（断点续传）**：

```
块0  → checkchunk → 已存在 ✅ → 跳过！（不重复上传）
块1  → checkchunk → 已存在 ✅ → 跳过！
块2  → checkchunk → 已存在 ✅ → 跳过！
块3  → checkchunk → 已存在 ✅ → 跳过！
块4  → checkchunk → 已存在 ✅ → 跳过！
块5  → checkchunk → 不存在 ❌ → uploadchunk → ✅ 成功（从这里继续）
块6  → checkchunk → 不存在 ❌ → uploadchunk → ✅ 成功
...
块19 → checkchunk → 不存在 ❌ → uploadchunk → ✅ 成功

所有块上传完成 → 调用 mergeChunks
```

**节省的流量**：

- 总文件：100MB
- 第一次已传：25MB（5 块）
- 第二次只需传：75MB（15 块）
- 节省流量：25MB ✅

### 5.2 后端如何检查分块是否存在？

```java
// MediaFileServiceImpl.java - checkChunk 方法
@Override
public RestResponse<Boolean> checkChunk(String fileMd5, int chunkIndex) {
    try {
        // 构建分块文件路径
        Path chunkPath = getChunkRootPath(fileMd5).resolve(String.valueOf(chunkIndex));
        // 例如：/tmp/xc-chunks/2125298091532905922013119cc3d2e9/5

        // 检查文件是否存在且大小大于0
        boolean exists = Files.exists(chunkPath) && Files.size(chunkPath) > 0;

        return RestResponse.success(exists);
    } catch (Exception e) {
        return RestResponse.success(false);
    }
}
```

**检查逻辑**：

1. 根据 `fileMd5` 和 `chunkIndex` 构建文件路径
2. 检查文件是否存在
3. 检查文件大小是否大于 0（防止空文件）
4. 返回 true/false

---

## 六、文件位置对照表

| 阶段       | 位置               | 文件形式 | 示例                               |
| ---------- | ------------------ | -------- | ---------------------------------- |
| 前端分块   | 浏览器内存         | 分块     | Blob 对象（5MB × 20）              |
| 上传分块   | 应用服务器临时目录 | 分块     | `/tmp/xc-chunks/{md5}/0`           |
| 合并文件   | 应用服务器临时目录 | 完整文件 | `/tmp/xc-merge-abc123.tmp` (100MB) |
| OSS 存储   | 阿里云 OSS         | 完整文件 | `2025/10/07/{md5}.mp4` (100MB)     |
| 数据库记录 | MySQL              | 元数据   | `media_files` 表一条记录           |

---

## 七、与 MinIO/OSS 分片上传的区别

### 7.1 你的项目（应用层分块）

```
浏览器 → [分块] → 应用服务器临时目录 → [合并] → 完整文件 → OSS
         ↑                              ↑
      断点续传检查                   MD5校验
```

**特点**：

- ✅ 实现简单
- ✅ 支持断点续传
- ✅ 可以进行业务逻辑处理
- ❌ 服务器需要临时存储空间
- ❌ 需要清理临时文件

### 7.2 OSS 原生分片上传（Multipart Upload）

```
浏览器 → [分片] → 直接上传到OSS → OSS合并
         ↑                        ↑
    OSS SDK管理              OSS自动合并
```

**特点**：

- ✅ 不占用服务器存储
- ✅ OSS 负责合并，服务器压力小
- ✅ 支持超大文件（最大 48.8TB）
- ❌ 实现复杂（需要管理 uploadId、partNumber 等）
- ❌ 依赖 OSS SDK
- ❌ 难以进行业务逻辑处理

### 7.3 对比总结

| 维度       | 应用层分块（你的项目） | OSS 分片上传   |
| ---------- | ---------------------- | -------------- |
| 实现复杂度 | ⭐⭐ 简单              | ⭐⭐⭐⭐ 复杂  |
| 服务器存储 | ❌ 需要临时空间        | ✅ 不占用      |
| 断点续传   | ✅ 支持                | ✅ 支持        |
| 业务处理   | ✅ 灵活                | ❌ 受限        |
| 文件大小   | ⚠️ 受服务器限制        | ✅ 最大 48.8TB |
| 适用场景   | 中小型文件（<5GB）     | 超大文件       |

---

## 八、常见误区澄清

### 误区 1：分块直接上传到 OSS ❌

**真相**：分块只保存在应用服务器，合并后才上传到 OSS

### 误区 2：OSS 自动合并分块 ❌

**真相**：应用服务器负责合并，OSS 只接收完整文件

### 误区 3：断点续传是 OSS 的功能 ❌

**真相**：断点续传是应用层实现的，通过检查服务器临时目录中的分块文件

### 误区 4：分块永久保存 ❌

**真相**：合并成功后立即删除，失败的分块需要定时任务清理

---

## 九、完整的时序图

```
前端浏览器          应用服务器                    阿里云OSS           MySQL数据库
    |                  |                            |                     |
    |-- 选择文件 ----->|                            |                     |
    |   (oceans.mp4)   |                            |                     |
    |                  |                            |                     |
    |-- 计算MD5 -----→|                            |                     |
    |   (前端计算)     |                            |                     |
    |                  |                            |                     |
    |-- checkfile --→|                            |                     |
    |                  |-- 查询数据库 ------------→|                     |-- SELECT -->
    |                  |←-- 不存在 ----------------←|                     |
    |←- 不存在 -------←|                            |                     |
    |                  |                            |                     |
    |== 开始分块上传 ==|                            |                     |
    |                  |                            |                     |
    |-- checkchunk(0)|                            |                     |
    |                  |-- 检查文件 /tmp/.../0     |                     |
    |←- 不存在 -------←|                            |                     |
    |                  |                            |                     |
    |-- uploadchunk(0, 块0数据) -->                |                     |
    |                  |-- 保存 /tmp/.../0 ✅      |                     |
    |←- 成功 ---------←|                            |                     |
    |                  |                            |                     |
    |-- checkchunk(1)|                            |                     |
    |←- 不存在 -------←|                            |                     |
    |-- uploadchunk(1, 块1数据) -->                |                     |
    |←- 成功 ---------←|                            |                     |
    |                  |                            |                     |
    |   ...（上传块2-19）...                        |                     |
    |                  |                            |                     |
    |== 所有块上传完成 =|                            |                     |
    |                  |                            |                     |
    |-- mergeChunks ->|                            |                     |
    |                  |                            |                     |
    |                  |-- 读取块0-19              |                     |
    |                  |-- 合并到临时文件           |                     |
    |                  |   /tmp/xc-merge-xxx.tmp   |                     |
    |                  |   (100MB完整文件) ✅      |                     |
    |                  |                            |                     |
    |                  |-- MD5校验                  |                     |
    |                  |   (计算合并文件的MD5)      |                     |
    |                  |   (对比原始MD5) ✅         |                     |
    |                  |                            |                     |
    |                  |-- 上传完整文件 ----------→|                     |
    |                  |                            |-- PUT Object -->   |
    |                  |                            |   (100MB mp4) ✅   |
    |                  |←-- 上传成功 --------------←|                     |
    |                  |                            |                     |
    |                  |-- 保存到数据库 ----------→|                     |-- INSERT -->
    |                  |                            |                     |
    |                  |-- 清理临时文件             |                     |
    |                  |   删除 /tmp/.../0-19 ✅   |                     |
    |                  |   删除 /tmp/.../目录 ✅    |                     |
    |                  |   删除 /tmp/xc-merge-xxx  |                     |
    |                  |         .tmp ✅            |                     |
    |                  |                            |                     |
    |←- 成功 ---------←|                            |                     |
    |                  |                            |                     |
```

---

## 十、验证你的理解

### 测试 1：查看临时目录

**在上传过程中**（上传到一半时暂停）：

```bash
# Windows
dir C:\Users\你的用户名\AppData\Local\Temp\xc-chunks\

# Linux
ls -lh /tmp/xc-chunks/
```

你会看到：

```
2125298091532905922013119cc3d2e9/
├── 0  (5MB)
├── 1  (5MB)
├── 2  (5MB)
└── ... (正在上传的块)
```

**上传完成后**：

```bash
# 临时目录应该是空的（所有分块已被清理）
ls -lh /tmp/xc-chunks/
# 可能输出：ls: cannot access '/tmp/xc-chunks/': No such file or directory
```

### 测试 2：断点续传

1. 上传一个大文件（50MB+）
2. 上传到 50%时，关闭浏览器
3. 打开浏览器控制台（F12）
4. 重新上传同一个文件
5. 观察控制台日志：
   ```
   success:: {num: 0, chunkCount: 20, state: 'uploading'}  // 跳过
   success:: {num: 1, chunkCount: 20, state: 'uploading'}  // 跳过
   ...
   success:: {num: 10, chunkCount: 20, state: 'uploading'} // 从这里开始真正上传
   ```

### 测试 3：查看 OSS

访问：https://yangxiaobucker.oss-cn-beijing.aliyuncs.com/2025/10/07/

你会看到：

- ✅ 完整的 mp4 文件（如 `2125298091532905922013119cc3d2e9.mp4`）
- ❌ 没有分块文件（如 `xxx.mp4.part0`、`xxx.mp4.part1`）

---

## 十一、总结

### 你的项目断点续传实现方式

1. **分块保存位置**：应用服务器临时目录（`/tmp/xc-chunks/{md5}/`）
2. **合并位置**：应用服务器（`/tmp/xc-merge-xxx.tmp`）
3. **上传到 OSS**：完整文件（合并后的完整 mp4）
4. **断点续传原理**：检查服务器临时目录中的分块文件是否存在
5. **清理机制**：合并成功后立即清理临时文件

### 关键要点

✅ **分块从未传到 OSS** - 只保存在应用服务器  
✅ **OSS 只存储完整文件** - 合并后才上传  
✅ **断点续传靠本地检查** - 检查服务器临时目录  
✅ **合并在服务器完成** - 不是 OSS 合并  
✅ **临时文件会被清理** - 成功后立即清理

### 与 MinIO/OSS 分片上传的区别

| 维度       | 你的实现（应用层） | OSS 分片上传（存储层） |
| ---------- | ------------------ | ---------------------- |
| 分块位置   | 应用服务器         | OSS 服务器             |
| 合并位置   | 应用服务器         | OSS 服务器             |
| 最终结果   | OSS 完整文件       | OSS 完整文件           |
| 实现难度   | 简单               | 复杂                   |
| 服务器压力 | 需要临时存储       | 无压力                 |

### 你的实现优势

1. **代码简单** - 易于理解和维护
2. **业务可控** - 可以在合并前后执行业务逻辑
3. **统一接口** - 所有文件都用同一个上传方法
4. **适合学习** - 清晰展示了分块、合并、校验的完整流程

**你的项目已经正确实现了断点续传，没有任何问题！** ✅
